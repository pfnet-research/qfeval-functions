import numpy as np
import torch
from sklearn.decomposition import PCA

import qfeval_functions
import qfeval_functions.functions as QF


class TestPCA:
    def test_pca(self) -> None:
        """Tests if the components generated by qfeval.pca corresponds to the
        result of sklearn.
        """
        qfeval_functions.random.seed()
        factors = QF.randn(100, 10) * QF.randn(10).exp()
        returns = torch.mm(factors, QF.randn(10, 10))
        d = PCA()
        d.fit(returns.numpy())
        expected = d.components_
        np.testing.assert_array_almost_equal(
            np.abs(QF.pca(returns).components.numpy()),
            np.abs(expected),
            decimal=3,
        )
        # Test if applying PCA to a batch of matrices works.
        batch_returns = returns[None, None].expand(3, 4, 100, 10)
        batch_result = QF.pca(batch_returns).components
        assert batch_result.shape == (3, 4, 10, 10)
        np.testing.assert_array_almost_equal(
            np.abs(batch_result.numpy()[0, 0]),
            np.abs(expected),
            decimal=3,
        )

        expected = d.explained_variance_
        np.testing.assert_array_almost_equal(
            np.abs(QF.pca(returns).explained_variance.numpy()),
            np.abs(expected),
            decimal=3,
        )
