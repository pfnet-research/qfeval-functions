import math

import numpy as np
import torch
from sklearn.decomposition import PCA

import qfeval_functions
import qfeval_functions.functions as QF


def test_nanpca() -> None:
    """Tests if the components generated by qfeval.pca corresponds to the
    result of sklearn.
    """
    qfeval_functions.random.seed()
    factors = QF.randn(100, 10) * QF.randn(10).exp()
    returns = torch.mm(factors, QF.randn(10, 10))
    d = PCA()
    d.fit(returns.numpy())
    pca_result = QF.nanpca(returns)
    expected = d.components_
    np.testing.assert_array_almost_equal(
        np.abs(pca_result.components.numpy()), np.abs(expected), decimal=3
    )
    np.testing.assert_array_almost_equal(
        np.abs(pca_result.explained_variance.numpy()),
        d.explained_variance_,
        decimal=3,
    )
    # Test if applying PCA to a batch of matrices works.
    batch_returns = returns[None, None].expand(3, 4, 100, 10)
    batch_result = QF.nanpca(batch_returns).components
    assert batch_result.shape == (3, 4, 10, 10)
    np.testing.assert_array_almost_equal(
        np.abs(batch_result.numpy()[0, 0]),
        np.abs(expected),
        decimal=3,
    )


def test_nanpca_with_nans() -> None:
    """Tests if nanpca estimates better than just filling NaNs with zeros."""
    qfeval_functions.random.seed()
    failed, succeeded = 0, 0
    for _ in range(100):
        factors = QF.randn(1000, 10) * QF.randn(10).exp()
        returns = torch.mm(factors, QF.randn(10, 10))
        d = PCA()
        d.fit(returns.numpy())
        expected = np.abs(d.components_)
        returns_with_nans = torch.where(
            QF.rand_like(returns) < 0.1,
            torch.as_tensor(math.nan),
            returns,
        )
        actual_nan_to_num = np.abs(
            QF.nanpca(returns_with_nans.nan_to_num()).components.numpy()
        )
        error_nan_to_num = (expected - actual_nan_to_num).std()
        actual_nanpca = np.abs(QF.nanpca(returns_with_nans).components.numpy())
        error_nanpca = (expected - actual_nanpca).std()
        if error_nanpca < error_nan_to_num:
            succeeded += 1
        else:
            failed += 1
    assert failed / (failed + succeeded) <= 0.1
